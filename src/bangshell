#!/usr/bin/env python3

# Binary Analysis Next Generation (BANG!)
#
# This file is part of BANG.
#
# BANG is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License,
# version 3, as published by the Free Software Foundation.
#
# BANG is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License, version 3, along with BANG. If not,
# see <http://www.gnu.org/licenses/>
#
# Copyright 2018-2021 - Armijn Hemel
# Licensed under the terms of the GNU Affero General Public
# License version 3
# SPDX-License-Identifier: AGPL-3.0-only

# This program provides a commandline interface to browsing the
# results of a scan made by BANG.

import cmd
import collections
import functools
import json
import math
import os
import pathlib
import pickle
import shutil
import stat
import sys


# Inspired by the example at:
# https://docs.python.org/3/library/cmd.html
#
# and the tutorial at:
#
# https://wiki.python.org/moin/CmdModule
class BangShell(cmd.Cmd):
    intro = 'Welcome to the BANG shell.  Type help or ? to list commands.\n'
    prompt = '(bang) '

    # store the results locally
    bang_results = None

    # keep a list of all file names for quick look up
    filenames = []

    # keep a list of all labels for quick look up
    labels = []

    # keep a mapping of labels to file
    labels_to_file = {}
    exclude_labels = set()
    stats_counter = collections.Counter()

    def clear(self):
        self.bang_results = None
        self.filenames = []
        self.labels = []
        self.labels_to_file = {}
        self.exclude_labels = set()
        self.stats_counter = collections.Counter()

    # load the data
    def do_load(self, arg):
        'Open a BANG scan directory and load scan data from it'
        args = arg.strip().split()

        # first check if the number of arguments is correct
        if len(args) != 1 or len(args) == 0:
            print("** invalid number of arguments: please only provide one argument\n")
            return

        # then check if the path exists
        bangdirectory = os.path.join(os.getcwd(), arg)
        if not os.path.exists(bangdirectory):
            print("** %s does not exist" % arg)
            return
        if not os.path.isdir(bangdirectory):
            print("** %s is not a directory" % arg)
            return

        # then check if a BANG pickle could be found
        bang_pickle_name = os.path.join(bangdirectory, "bang.pickle")
        if not os.path.exists(bang_pickle_name):
            print("** %s is not a valid BANG result directory\n" % arg)
            return

        # first clear any old results
        self.clear()

        try:
            with open(bang_pickle_name, 'rb') as bang_pickle:
                self.bang_results = pickle.load(bang_pickle)
        except:
            print("** could not unpackle bang.pickle in %s\n" % arg)
            return

        for i in self.bang_results['scantree']:
            self.labels += self.bang_results['scantree'][i]['labels']
            for label in self.bang_results['scantree'][i]['labels']:
                if label not in self.labels_to_file:
                    self.labels_to_file[label] = []
                self.labels_to_file[label].append(self.bang_results['scantree'][i]['filename'])
            self.stats_counter.update(self.bang_results['scantree'][i]['labels'])
            self.filenames.append(i)

        # deduplicate the labels and sort them alphabetically
        self.labels = list(set(self.labels))
        self.labels.sort()

        # alphabetically sort the file names
        self.filenames.sort()

    # a method to ignore files with a specific label
    def do_exclude(self, arg):
        'Exclude files with a certain label from results'
        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return
        args = arg.strip().split()
        if len(args) < 1:
            print("** invalid number of arguments: no label given\n")
            return
        if args[0] in self.labels:
            self.exclude_labels.add(args[0])

    # a method to stop ignoring files with a specific label
    def do_include(self, arg):
        'Include files with a certain label in results'
        pass
        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return
        args = arg.strip().split()
        if len(args) < 1:
            print("** invalid number of arguments: no label given\n")
            return
        if args[0] in self.exclude_labels:
            self.exclude_labels.remove(args[0])

    def do_labels(self, arg):
        'Show labels'
        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return

        self.format_entries(self.labels)
        if self.exclude_labels != set():
            exclude_labels = list(self.exclude_labels)
            print("Currently excluded:")
            self.format_entries(exclude_labels)

    # implement something like ls for files
    def do_ls(self, arg):
        'Show files and directories from scan'
        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return
        args = list(filter(lambda x: x != '', map(lambda x: x.strip(), arg.strip().split(' ', 1))))
        if len(args) < 1:
            # no specific file was looked at, so
            # just display the list of all files
            self.format_entries(self.filenames)
        else:
            lscmds = set()

            # first check if any flags were given
            while True:
                if not args[0].startswith('-'):
                    break

                if args[0] == '-l':
                    lscmds.add('l')

                args = args[1:]

                # see if there are any more args to process
                if len(args) > 1:
                    args = list(filter(lambda x: x != '', map(lambda x: x.strip(), args[0].strip().split(' ', 1))))
                    if args == []:
                        break
                else:
                    break

                    # treat the rest as a filename
                    if args == []:
                        if 'l' in lscmds:
                            self.format_entries(self.filenames)
                        else:
                            self.format_entries(self.filenames)
                    else:
                        if args[0] in self.filenames:
                            if 'l' in lscmds:
                                print(self.bang_results['scantree'][args[0]])
                                self.format_entries(args)
                            else:
                                self.format_entries(args)

    def do_show(self, arg):
        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return

        args = arg.strip().split()
        if len(args) < 1:
            print("** invalid number of arguments: no subcommand given\n")
            return

        if args[0] == 'label':
            if len(args) < 2:
                print("** provide a label name\n")
                return
            if len(args) > 2:
                print("** too many parameters\n")
                return

            label = args[1]
            if label not in self.labels:
                print("** no results for label '%s'\n" % label)
                return

            label_keys = self.labels_to_file[label]
            label_keys.sort()
            self.format_entries(label_keys)

    def do_runtime_stats(self, arg):
        'Show run time statistics about the scan'

        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return

        if 'session' in self.bang_results:
            print("Scan started: %s" % self.bang_results['session']['start'].isoformat())
            print("Scan finished: %s" % self.bang_results['session']['stop'].isoformat())
            print("Scan duration: %f seconds" % self.bang_results['session']['duration'])
            print("Scan run by: %s\n" % self.bang_results['session']['user'])

    def do_summary(self, arg):
        'Print a summary about the scan'

        if self.bang_results is None:
            print("** first load BANG results using 'load'\n")
            return

        print("Total entries: %d\n" % len(self.filenames))
        for i in self.stats_counter.most_common():
            print("%s: %d" % i)

    def do_exit(self, arg):
        'Exit bang shell'
        print('Going out with a BANG!')
        return True

    do_EOF = do_exit

    # format entries based on the terminal size, etc.
    def format_entries(self, entries):
        # get the current terminal size first, then pretty print
        # the labels accordingly in left adjusted columns, much
        # like "ls" does: create columns that are max(labels) + 2
        # wide for every entry.
        termsize = shutil.get_terminal_size()
        maxentrysize = max(map(lambda x: len(x), entries))

        # the amount of columns that will be used
        if maxentrysize + 2 > termsize.columns:
            entrycolumns = 1
        else:
            entrycolumns = termsize.columns//(maxentrysize+2)

        lines_used = math.ceil(len(entries)/entrycolumns)

        columnsleft = termsize.columns

        # If only one line is used then only having two spaces
        # between entries is enough.
        #
        # If more than one line is used then columns have to be
        # constructed, similar to what the "ls" command does.
        if lines_used == 1:
            print(functools.reduce(lambda x, y: x + "  " + y, entries), '\n')
        else:
            entrystr = ""
            for line in entries:
                if maxentrysize + 2 > columnsleft:
                    print(entrystr)
                    columnsleft = termsize.columns
                    entrystr = ""
                    entrystr += line.ljust(maxentrysize + 2)
                    columnsleft -= (maxentrysize + 2)
                else:
                    entrystr += line.ljust(maxentrysize + 2)
                    columnsleft -= (maxentrysize + 2)
            if entrystr != "":
                print(entrystr)

    def emptyline(self):
        return

if __name__ == '__main__':
    BangShell().cmdloop()
